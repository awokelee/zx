# 0.1 + 0.2 != 0.3

`JavaScript` 内部，所有数字都是以 `64` 位浮点数形式储存，即使整数也是如此。所以，`1` 与 `1.0` 是相同的，是同一个数。

```js
1 === 1.0 // true
```

这就是说，`JavaScript` 语言的底层根本没有整数，所有数字都是小数（**64位浮点数**）。容易造成混淆的是，某些运算只有整数才能完成，此时 `JavaScript` 会自动把 `64` 位浮点数，转成 `32` 位整数，然后再进行运算。

由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。

```js
0.1 + 0.2 === 0.3
// false

0.3 / 0.1
// 2.9999999999999996

(0.3 - 0.2) === (0.2 - 0.1)
// false
```

根据国际标准 `IEEE 754`，`JavaScript` 浮点数的 `64` 个二进制位，从最左边开始，是这样组成的。

第 `1` 位：符号位，`0` 表示正数，`1` 表示负数

第 `2` 位到第 `12` 位（共 `11` 位）：指数部分

第 `13` 位到第 `64` 位（共52位）：小数部分（即有效数字）

符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。

指数部分一共有 `11` 个二进制位，因此大小范围就是 `0` 到 `2047`。`IEEE 754` 规定，如果指数部分的值在 `0` 到 `2047` 之间（不含两个端点），那么有效数字的第一位默认总是 `1`，不保存在 `64` 位浮点数之中。也就是说，有效数字这时总是 `1.xx...xx` 的形式，其中 `xx..xx` 的部分保存在 `64` 位浮点数之中，最长可能为 `52` 位。因此，`JavaScript` 提供的有效数字最长为 `53` 个二进制位。

```js
(-1)^符号位 * 1.xx...xx * 2^指数部分
```

上面公式是正常情况下（指数部分在 `0` 到 `2047` 之间），一个数在 `JavaScript` 内部实际的表示形式。

精度最多只能到 `53` 个二进制位，这意味着，绝对值小于等于 `2` 的 `53` 次方的整数，即 `-253` 到 `253`，都可以精确表示。

- 结果

```js
`0.1 = 2^-4 * 1.10011(0011)`

`0.2 = 2^-3 * 1.10011(0011)`

// 这个值换成十进制就是 `0.30000000000000004`
`0.1 + 0.2 = 2^-2 * 1.0011(0011 * 11次)0100`
```

- 解决办法

```js
parseFloat((0.1 + 0.2).toFixed(10))
```

::: tip 相关链接:
[https://wangdoc.com/javascript/types/number.html](https://wangdoc.com/javascript/types/number.html), by 阮一峰.

[https://yuchengkai.cn/docs/zh/frontend](https://yuchengkai.cn/docs/zh/frontend), by InterviewMap
:::