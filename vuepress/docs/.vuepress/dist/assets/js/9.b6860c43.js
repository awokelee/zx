(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{156:function(e,n,t){"use strict";t.r(n);var s=t(0),r=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"promise教程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise教程","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise教程")]),t("h2",{attrs:{id:"_1、promise-的声明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、promise-的声明","aria-hidden":"true"}},[e._v("#")]),e._v(" 1、Promise 的声明")]),t("p",[e._v("首先呢，"),t("code",[e._v("promise")]),e._v(" 肯定是一个类，我们就用class来声明。")]),t("p",[e._v("由于"),t("code",[e._v("new Promise((resolve, reject)=>{})")]),e._v("，所以传入一个参数（函数），秘籍里叫他executor，传入就执行。\nexecutor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。\n由于resolve和reject可执行，所以都是函数，我们用let声明。")]),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),t("span",{attrs:{class:"token class-name"}},[e._v("Promise")]),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),t("span",{attrs:{class:"token comment"}},[e._v("// 构造器")]),e._v("\n  "),t("span",{attrs:{class:"token function"}},[e._v("constructor")]),t("span",{attrs:{class:"token punctuation"}},[e._v("(")]),e._v("executor"),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{attrs:{class:"token comment"}},[e._v("// 成功")]),e._v("\n    "),t("span",{attrs:{class:"token keyword"}},[e._v("let")]),e._v(" "),t("span",{attrs:{class:"token function-variable function"}},[e._v("resolve")]),e._v(" "),t("span",{attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{attrs:{class:"token comment"}},[e._v("// 失败")]),e._v("\n    "),t("span",{attrs:{class:"token keyword"}},[e._v("let")]),e._v(" "),t("span",{attrs:{class:"token function-variable function"}},[e._v("reject")]),e._v(" "),t("span",{attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{attrs:{class:"token comment"}},[e._v("// 立即执行")]),e._v("\n    "),t("span",{attrs:{class:"token function"}},[e._v("executor")]),t("span",{attrs:{class:"token punctuation"}},[e._v("(")]),e._v("resolve"),t("span",{attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" reject"),t("span",{attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),t("span",{attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),t("h3",{attrs:{id:"解决基本状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决基本状态","aria-hidden":"true"}},[e._v("#")]),e._v(" 解决基本状态")]),t("p",[e._v("秘籍对Promise有规定：")]),t("p",[e._v("Promise存在三个状态（state）pending、fulfilled、rejected")]),t("p",[e._v("pending（等待态）为初始态，并可以转化为fulfilled（成功态）和rejected（失败态）")]),t("p",[e._v("成功时，不可转为其他状态，且必须有一个不可改变的值（value）")]),t("p",[e._v("失败时，不可转为其他状态，且必须有一个不可改变的原因（reason）")]),t("p",[e._v("new Promise((resolve, reject)=>{resolve(value)}) resolve为成功，接收参数value，状态改变为fulfilled，不可再次改变。")]),t("p",[e._v("new Promise((resolve, reject)=>{reject(reason)}) reject为失败，接收参数reason，状态改变为rejected，不可再次改变。")]),t("p",[e._v("若是executor函数报错 直接执行reject();")]),t("p",[e._v("于是乎，我们获得以下代码\nclass Promise{\nconstructor(executor){\n// 初始化state为等待态\nthis.state = 'pending';\n// 成功的值\nthis.value = undefined;\n// 失败的原因\nthis.reason = undefined;\nlet resolve = value => {\n// state改变,resolve调用就会失败\nif (this.state === 'pending') {\n// resolve调用后，state转化为成功态\nthis.state = 'fulfilled';\n// 储存成功的值\nthis.value = value;\n}\n};\nlet reject = reason => {\n// state改变,reject调用就会失败\nif (this.state === 'pending') {\n// reject调用后，state转化为失败态\nthis.state = 'rejected';\n// 储存失败的原因\nthis.reason = reason;\n}\n};\n// 如果executor执行报错，直接执行reject\ntry{\nexecutor(resolve, reject);\n} catch (err) {\nreject(err);\n}\n}\n}")]),t("p",[e._v("then方法\n秘籍规定:Promise有一个叫做then的方法，里面有两个参数：onFulfilled,onRejected,成功有成功的值，失败有失败的原因")]),t("p",[e._v("当状态state为fulfilled，则执行onFulfilled，传入this.value。当状态state为rejected，则执行onRejected，传入this.value\nonFulfilled,onRejected如果他们是函数，则必须分别在fulfilled，rejected后被调用，value或reason依次作为他们的第一个参数")]),t("p",[e._v("class Promise{\nconstructor(executor){...}\n// then 方法 有两个参数onFulfilled onRejected\nthen(onFulfilled,onRejected) {\n// 状态为fulfilled，执行onFulfilled，传入成功的值\nif (this.state === 'fulfilled') {\nonFulfilled(this.value);\n};\n// 状态为rejected，执行onRejected，传入失败的原因\nif (this.state === 'rejected') {\nonRejected(this.reason);\n};\n}\n}")]),t("p",[e._v("解决异步实现\n现在基本可以实现简单的同步代码，但是当resolve在setTomeout内执行，then时state还是pending等待状态 我们就需要在then调用的时候，将成功和失败存到各自的数组，一旦reject或者resolve，就调用它们\n类似于发布订阅，先将then里面的两个函数储存起来，由于一个promise可以有多个then，所以存在同一个数组内。\n// 多个then的情况\nlet p = new Promise();\np.then();\np.then();\n成功或者失败时，forEach调用它们\nclass Promise{\nconstructor(executor){\nthis.state = 'pending';\nthis.value = undefined;\nthis.reason = undefined;\n// 成功存放的数组\nthis.onResolvedCallbacks = [];\n// 失败存放法数组\nthis.onRejectedCallbacks = [];\nlet resolve = value => {\nif (this.state === 'pending') {\nthis.state = 'fulfilled';\nthis.value = value;\n// 一旦resolve执行，调用成功数组的函数\nthis.onResolvedCallbacks.forEach(fn=>fn());\n}\n};\nlet reject = reason => {\nif (this.state === 'pending') {\nthis.state = 'rejected';\nthis.reason = reason;\n// 一旦reject执行，调用失败数组的函数\nthis.onRejectedCallbacks.forEach(fn=>fn());\n}\n};\ntry{\nexecutor(resolve, reject);\n} catch (err) {\nreject(err);\n}\n}\nthen(onFulfilled,onRejected) {\nif (this.state === 'fulfilled') {\nonFulfilled(this.value);\n};\nif (this.state === 'rejected') {\nonRejected(this.reason);\n};\n// 当状态state为pending时\nif (this.state === 'pending') {\n// onFulfilled传入到成功数组\nthis.onResolvedCallbacks.push(()=>{\nonFulfilled(this.value);\n})\n// onRejected传入到失败数组\nthis.onRejectedCallbacks.push(()=>{\nonRejected(this.reason);\n})\n}\n}\n}\n解决链式调用\n我门常常用到new Promise().then().then(),这就是链式调用，用来解决回调地狱\n1、为了达成链式，我们默认在第一个then里返回一个promise。秘籍规定了一种方法，就是在then里面返回一个新的promise,称为promise2：promise2 = new Promise((resolve, reject)=>{})")]),t("p",[e._v("将这个promise2返回的值传递到下一个then中\n如果返回一个普通的值，则将普通的值传递给下一个then中")]),t("p",[e._v("2、当我们在第一个then中return了一个参数（参数未知，需判断）。这个return出来的新的promise就是onFulfilled()或onRejected()的值\n秘籍则规定onFulfilled()或onRejected()的值，即第一个then返回的值，叫做x，判断x的函数叫做resolvePromise")]),t("p",[e._v("首先，要看x是不是promise。\n如果是promise，则取它的结果，作为新的promise2成功的结果\n如果是普通值，直接作为promise2成功的结果\n所以要比较x和promise2\nresolvePromise的参数有promise2（默认返回的promise）、x（我们自己return的对象）、resolve、reject\nresolve和reject是promise2的")]),t("p",[e._v("class Promise{\nconstructor(executor){\nthis.state = 'pending';\nthis.value = undefined;\nthis.reason = undefined;\nthis.onResolvedCallbacks = [];\nthis.onRejectedCallbacks = [];\nlet resolve = value => {\nif (this.state === 'pending') {\nthis.state = 'fulfilled';\nthis.value = value;\nthis.onResolvedCallbacks.forEach(fn=>fn());\n}\n};\nlet reject = reason => {\nif (this.state === 'pending') {\nthis.state = 'rejected';\nthis.reason = reason;\nthis.onRejectedCallbacks.forEach(fn=>fn());\n}\n};\ntry{\nexecutor(resolve, reject);\n} catch (err) {\nreject(err);\n}\n}\nthen(onFulfilled,onRejected) {\n// 声明返回的promise2\nlet promise2 = new Promise((resolve, reject)=>{\nif (this.state === 'fulfilled') {\nlet x = onFulfilled(this.value);\n// resolvePromise函数，处理自己return的promise和默认的promise2的关系\nresolvePromise(promise2, x, resolve, reject);\n};\nif (this.state === 'rejected') {\nlet x = onRejected(this.reason);\nresolvePromise(promise2, x, resolve, reject);\n};\nif (this.state === 'pending') {\nthis.onResolvedCallbacks.push(()=>{\nlet x = onFulfilled(this.value);\nresolvePromise(promise2, x, resolve, reject);\n})\nthis.onRejectedCallbacks.push(()=>{\nlet x = onRejected(this.reason);\nresolvePromise(promise2, x, resolve, reject);\n})\n}\n});\n// 返回promise，完成链式\nreturn promise2;\n}\n}\n完成resolvePromise函数\n秘籍规定了一段代码，让不同的promise代码互相套用，叫做resolvePromise")]),t("p",[e._v("如果 x === promise2，则是会造成循环引用，自己等待自己完成，则报“循环引用”错误")]),t("p",[e._v("let p = new Promise(resolve => {\nresolve(0);\n});\nvar p2 = p.then(data => {\n// 循环引用，自己等待自己完成，一辈子完不成\nreturn p2;\n})\n1、判断x")]),t("p",[e._v("Otherwise, if x is an object or function,Let then be x.then\nx 不能是null\nx 是普通值 直接resolve(x)\nx 是对象或者函数（包括promise），let then = x.then\n2、当x是对象或者函数（默认promise）\n声明了then\n如果取then报错，则走reject()\n如果then是个函数，则用call执行then，第一个参数是this，后面是成功的回调和失败的回调\n如果成功的回调还是pormise，就递归继续解析\n3、成功和失败只能调用一个 所以设定一个called来防止多次调用")]),t("p",[e._v("function resolvePromise(promise2, x, resolve, reject){\n// 循环引用报错\nif(x === promise2){\n// reject报错\nreturn reject(new TypeError('Chaining cycle detected for promise'));\n}\n// 防止多次调用\nlet called;\n// x不是null 且x是对象或者函数\nif (x != null && (typeof x === 'object' || typeof x === 'function')) {\ntry {\n// A+规定，声明then = x的then方法\nlet then = x.then;\n// 如果then是函数，就默认是promise了\nif (typeof then === 'function') {\n// 就让then执行 第一个参数是this   后面是成功的回调 和 失败的回调\nthen.call(x, y => {\n// 成功和失败只能调用一个\nif (called) return;\ncalled = true;\n// resolve的结果依旧是promise 那就继续解析\nresolvePromise(promise2, y, resolve, reject);\n}, err => {\n// 成功和失败只能调用一个\nif (called) return;\ncalled = true;\nreject(err);// 失败了就失败了\n})\n} else {\nresolve(x); // 直接成功即可\n}\n} catch (e) {\n// 也属于失败\nif (called) return;\ncalled = true;\n// 取then出错了那就不要在继续执行了\nreject(e);\n}\n} else {\nresolve(x);\n}\n}\n解决其他问题\n1、秘籍规定onFulfilled,onRejected都是可选参数，如果他们不是函数，必须被忽略")]),t("p",[e._v("onFulfilled返回一个普通的值，成功时直接等于 value => value\nonRejected返回一个普通的值，失败时如果直接等于 value => value，则会跑到下一个then中的onFulfilled中，所以直接扔出一个错误reason => throw err\n2、秘籍规定onFulfilled或onRejected不能同步被调用，必须异步调用。我们就用setTimeout解决异步问题\n如果onFulfilled或onRejected报错，则直接返回reject()")]),t("p",[e._v("class Promise{\nconstructor(executor){\nthis.state = 'pending';\nthis.value = undefined;\nthis.reason = undefined;\nthis.onResolvedCallbacks = [];\nthis.onRejectedCallbacks = [];\nlet resolve = value => {\nif (this.state === 'pending') {\nthis.state = 'fulfilled';\nthis.value = value;\nthis.onResolvedCallbacks.forEach(fn=>fn());\n}\n};\nlet reject = reason => {\nif (this.state === 'pending') {\nthis.state = 'rejected';\nthis.reason = reason;\nthis.onRejectedCallbacks.forEach(fn=>fn());\n}\n};\ntry{\nexecutor(resolve, reject);\n} catch (err) {\nreject(err);\n}\n}\nthen(onFulfilled,onRejected) {\n// onFulfilled如果不是函数，就忽略onFulfilled，直接返回value\nonFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n// onRejected如果不是函数，就忽略onRejected，直接扔出错误\nonRejected = typeof onRejected === 'function' ? onRejected : err => { throw err };\nlet promise2 = new Promise((resolve, reject) => {\nif (this.state === 'fulfilled') {\n// 异步\nsetTimeout(() => {\ntry {\nlet x = onFulfilled(this.value);\nresolvePromise(promise2, x, resolve, reject);\n} catch (e) {\nreject(e);\n}\n}, 0);\n};\nif (this.state === 'rejected') {\n// 异步\nsetTimeout(() => {\n// 如果报错\ntry {\nlet x = onRejected(this.reason);\nresolvePromise(promise2, x, resolve, reject);\n} catch (e) {\nreject(e);\n}\n}, 0);\n};\nif (this.state === 'pending') {\nthis.onResolvedCallbacks.push(() => {\n// 异步\nsetTimeout(() => {\ntry {\nlet x = onFulfilled(this.value);\nresolvePromise(promise2, x, resolve, reject);\n} catch (e) {\nreject(e);\n}\n}, 0);\n});\nthis.onRejectedCallbacks.push(() => {\n// 异步\nsetTimeout(() => {\ntry {\nlet x = onRejected(this.reason);\nresolvePromise(promise2, x, resolve, reject);\n} catch (e) {\nreject(e);\n}\n}, 0)\n});\n};\n});\n// 返回promise，完成链式\nreturn promise2;\n}\n}")]),t("h2",{attrs:{id:"大功告成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#大功告成","aria-hidden":"true"}},[e._v("#")]),e._v(" 大功告成")]),t("p",[e._v("顺便附赠catch和resolve、reject、race、all方法\nclass Promise{\nconstructor(executor){\nthis.state = 'pending';\nthis.value = undefined;\nthis.reason = undefined;\nthis.onResolvedCallbacks = [];\nthis.onRejectedCallbacks = [];\nlet resolve = value => {\nif (this.state === 'pending') {\nthis.state = 'fulfilled';\nthis.value = value;\nthis.onResolvedCallbacks.forEach(fn=>fn());\n}\n};\nlet reject = reason => {\nif (this.state === 'pending') {\nthis.state = 'rejected';\nthis.reason = reason;\nthis.onRejectedCallbacks.forEach(fn=>fn());\n}\n};\ntry{\nexecutor(resolve, reject);\n} catch (err) {\nreject(err);\n}\n}\nthen(onFulfilled,onRejected) {\nonFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\nonRejected = typeof onRejected === 'function' ? onRejected : err => { throw err };\nlet promise2 = new Promise((resolve, reject) => {\nif (this.state === 'fulfilled') {\nsetTimeout(() => {\ntry {\nlet x = onFulfilled(this.value);\nresolvePromise(promise2, x, resolve, reject);\n} catch (e) {\nreject(e);\n}\n}, 0);\n};\nif (this.state === 'rejected') {\nsetTimeout(() => {\ntry {\nlet x = onRejected(this.reason);\nresolvePromise(promise2, x, resolve, reject);\n} catch (e) {\nreject(e);\n}\n}, 0);\n};\nif (this.state === 'pending') {\nthis.onResolvedCallbacks.push(() => {\nsetTimeout(() => {\ntry {\nlet x = onFulfilled(this.value);\nresolvePromise(promise2, x, resolve, reject);\n} catch (e) {\nreject(e);\n}\n}, 0);\n});\nthis.onRejectedCallbacks.push(() => {\nsetTimeout(() => {\ntry {\nlet x = onRejected(this.reason);\nresolvePromise(promise2, x, resolve, reject);\n} catch (e) {\nreject(e);\n}\n}, 0)\n});\n};\n});\nreturn promise2;\n}\ncatch(fn){\nreturn this.then(null,fn);\n}\n}\nfunction resolvePromise(promise2, x, resolve, reject){\nif(x === promise2){\nreturn reject(new TypeError('Chaining cycle detected for promise'));\n}\nlet called;\nif (x != null && (typeof x === 'object' || typeof x === 'function')) {\ntry {\nlet then = x.then;\nif (typeof then === 'function') {\nthen.call(x, y => {\nif(called)return;\ncalled = true;\nresolvePromise(promise2, y, resolve, reject);\n}, err => {\nif(called)return;\ncalled = true;\nreject(err);\n})\n} else {\nresolve(x);\n}\n} catch (e) {\nif(called)return;\ncalled = true;\nreject(e);\n}\n} else {\nresolve(x);\n}\n}\n//resolve方法\nPromise.resolve = function(val){\nreturn new Promise((resolve,reject)=>{\nresolve(val)\n});\n}\n//reject方法\nPromise.reject = function(val){\nreturn new Promise((resolve,reject)=>{\nreject(val)\n});\n}\n//race方法\nPromise.race = function(promises){\nreturn new Promise((resolve,reject)=>{\nfor(let i=0;i<promises.length;i++){\npromises[i].then(resolve,reject)\n};\n})\n}\n//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)\nPromise.all = function(promises){\nlet arr = [];\nlet i = 0;\nfunction processData(index,data){\narr[index] = data;\ni++;\nif(i == promises.length){\nresolve(arr);\n};\n};\nreturn new Promise((resolve,reject)=>{\nfor(let i=0;i<promises.length;i++){\npromises[i].then(data=>{\nprocessData(i,data);\n},reject);\n};\n});\n}\n如何验证我们的promise是否正确\n1、先在后面加上下述代码\n2、npm 有一个promises-aplus-tests插件 npm i promises-aplus-tests -g 可以全局安装 mac用户最前面加上sudo\n3、命令行 promises-aplus-tests [js文件名] 即可验证\n// 目前是通过他测试 他会测试一个对象\n// 语法糖\nPromise.defer = Promise.deferred = function () {\nlet dfd = {}\ndfd.promise = new Promise((resolve,reject)=>{\ndfd.resolve = resolve;\ndfd.reject = reject;\n});\nreturn dfd;\n}\nmodule.exports = Promise;\n//npm install promises-aplus-tests 用来测试自己的promise 符不符合promisesA+规范")]),t("p",[e._v("作者：卡姆爱卡姆\n链接：https://juejin.im/post/5b2f02cd5188252b937548ab\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")])])}],!1,null,null,null);n.default=r.exports}}]);