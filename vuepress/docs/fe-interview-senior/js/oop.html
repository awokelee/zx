<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>oop</title>
</head>

<body>
  <script>
    /**
     * 类的声明
     */
    function Animal1() {
      this.name = 'name'
    }
    /**
     * ES6 中的 class 声明 
     */
    class Animal2 {
      constructor() {
        this.name = name;
      }
    }
    /**
     * 实例化
     */
    // console.log(new Animal1(), new Animal2())




    /**
     * 借助构造函数实现继承:
     *    原理: 改变运行时 this 指向
     *    缺点: 部分继承, 只能继承构造函数里面的属性, 如果是在父类原型对象上的就不行
     */
    function Parent1() {
      this.name = 'parent1';
    }

    Parent1.prototype.say = function () {
      console.log('say')
    }

    function Child1() {
      Parent1.call(this); // apply
      this.type = 'child1';
    }
    // Child1 {name: "parent1", type: "child1"}
    // .say is not a function
    // console.log(new Child1(), new Child1().say())

/************************************/

    /**
     * 借助原型链实现继承
     *    缺点: 原型链上原型对象是公用的
     */
    function Parent2() {
      this.name = 'Parent2';
      this.play = [1, 2, 3];
    }

    function Child2() {
      this.type = 'Child2';
    }

    // 原型链基本原理
    // 1. Child2 是个函数, 每个函数有 prototype 对象.
    // 2. new Parent2() 得到的是个实例
    // 3. 实例赋值给 Child2.prototype
    Child2.prototype = new Parent2();

    // new Child2() 得到一个对象, new Child2().__proto__ 属性 等于 Child2.prototype
    /*
     console.log(new Child2()) 打印如下:
     
     Child2 {type: "Child2"}
       type: "Child2"
       __proto__: Parent2
           name: "Parent2"
     */

    /*
      // true
      new Child2().__proto__ === Child2.prototype
      // "Parent2"
      new Child2().__proto__.name
    */

    var s1 = new Child2()
    var s2 = new Child2()
    s1.play.push(4);

    // s1.play: [1, 2, 3, 4]
    // s2.play: [1, 2, 3, 4]
    // console.log(s1.play, s2.play)
    
    // true
    // s1.__proto__ === s2.__proto__ 

/************************************/

    /**
     * 组合方式, 通用的方式
     *      缺点: 实例化子类构造函数时, 父类构造函数执行了两次
     */
     function Parent3() {
      this.name = 'parent3';
      this.play = [1, 2, 3]
    }
    function Child3() {
      Parent3.call(this); // 1次
      this.type = 'child3';
    }
    Child3.prototype = new Parent3(); // 2次
    var s3 = new Child3()
    var s4 = new Child3()
    s3.play.push(4);

    // s3.play: [1, 2, 3, 4]
    // s4.play: [1, 2, 3]
    // console.log(s3.play, s4.play)

    /*
      Parent3() {
        this.name = 'parent3';
        this.play = [1, 2, 3]
      }
    */
    // console.log(s3.constructor) 

/************************************/

    /**
     * 组合方式继承的优化1
     *     缺点: 构造函数是父类的
     */
     function Parent4() {
      this.name = 'parent4';
      this.play = [1, 2, 3]
    }
    function Child4() {
      Parent4.call(this);
      this.type = 'child4';
    }
    Child4.prototype = Parent4.prototype;
    var s5 = new Child4()
    var s6 = new Child4()
    // console.log(s5, s6)

    // true true
    // console.log(s5 instanceof Child4, s5 instanceof Parent4) 
    
    /*
      Parent4() {
        this.name = 'parent3';
        this.play = [1, 2, 3]
      }
    */
    // console.log(s5.constructor) 

/************************************/

    /**
     * 组合方式继承的优化2
     *   完美
     */
     function Parent5() {
      this.name = 'parent3';
      this.play = [1, 2, 3]
    }
    function Child5() {
      Parent5.call(this);
      this.type = 'child3';
    }
    // Object.create 创建的对象的原型对象就是参数.
    Child5.prototype = Object.create(Parent5.prototype); // __proto__
    Child5.prototype.constructor = Child5;
    var s7 = new Child5()
    var s8 = new Child5()
    // true true
    console.log(s7 instanceof Child5, s7 instanceof Parent5) 
    /*
      Child5() {
        Parent5.call(this);
        this.type = 'child3';
      }
    */
    console.log(s7.constructor) 
  </script>
</body>

</html>