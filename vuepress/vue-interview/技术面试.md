# 技术面试

// TODO

```md
vuex 模块化
vue cli3
推特
vue 最佳实践
vue 管理后台代码
vue 权限
首屏优化
SSR
埋点
抓包
优化对比  加载时间包大小
具有性能优化经验，熟练使用各种调试、抓包工具，能独立分析、解决和归纳问题
```

```md
布局
  水平垂直居中
  三栏布局(高度已知)
  圣杯和双飞翼
  flex
CSS
  css的position属性有哪些取值，它们的行为是什么
  CSS3
  BEM
DOM 事件
  DOM 级别
  冒泡捕获
  自定义事件
JavaScript
  值、引用
  原型、原型链
  提升
  01+0.2
  深拷贝
  递归
  VO
  防抖
  节流
  event-loop
HTML
  Doctype
  HTML5
  语义化
  盒模型
  BFC
  外边距重叠
网络
  HTTP
  HTTPS
  HTTP2
  强缓存
  协商缓存
  跨域
安全
监控
埋点
抓包
ES6
promise
proxy
异步、同步
webworker
websocket
Webpack
Vue
React
Angular
设计模式
数据结构
算法
```

```md
FOUC
XMLHttpRequest
css的position属性有哪些取值，它们的行为是什么？
  这个题目几乎是我每次必问的，因为这个题区分度、深度和覆盖范围都很高。这个题的答案可以分成不同的层级:

  position属性常用的取值static、relative以及absolute和它们的基本行为是每个前端都应该掌握的。这包括relative和absolute的定位原点。
  fixed旧版本IE不支持，但是一个对技术有热情的工程师也是应该了解的。
  有过研究工程师可以知道absolute的containing block计算方式跟正常流不同，当然如果没读过标准的话，表述方式不一定是这样。
  对CSS布局有深入研究的工程师会知道position跟display、margin collapse、overflow、float这些特性相互叠加后的行为。
```

一般来说，当面试者遇到困难或者长时间思考时，面试官应当给予提示来节约时间，而当面试者给出的答案不够具体或者回答得过于轻松时，可以适当追问。在我的微博中

其实这问题我本来打算的是可以顺着一路扯到normal flow、containing block、bfc、margin collapse，base line，writing mode，bidi，这样一路问下去的，奈何第一个问题（亲我真的只问了position有哪些取值和行为啊）就悲剧了……

我提到了一些我准备的追问内容，这些知识点从前到后越来越细致，也越来越偏，从最开始的box排布，到后面的行模型，再到文本排版，基本上是网页排版从整体到细节的顺序。

## 实现Bind函数

```js
// bind()函数在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。你可以部份地在脚本开头加入以下代码，就能使它运作，让不支持的浏览器也能使用 bind() 功能。

if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs   = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP    = function() {},
        fBound  = function() {
          // this instanceof fNOP === true时,说明返回的fBound被当做new的构造函数调用
          return fToBind.apply(this instanceof fNOP
                 ? this
                 : oThis,
                 // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的
                 aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    // 维护原型关系
    if (this.prototype) {
      // Function.prototype doesn't have a prototype property
      fNOP.prototype = this.prototype; 
    }
    // 下行的代码使fBound.prototype是fNOP的实例,因此
    // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例
    fBound.prototype = new fNOP();

    return fBound;
  };
}
```
